## [P2607 骑士](https://www.luogu.com.cn/problem/P2607)

### 题意：

有 $n$ 个骑士，第 $i$ 个人有战力值 $a_i$ 和一个讨厌的骑士 $b_i$（$b_i\ne i$）。每个骑士不愿和自己讨厌的骑士待在一起，求由若干个骑士组成的骑士团的战力值总和的最大值。

其中，$1\le n,a_i\le10^6$

### 分析：

若我们将每个骑士看作一个点，并将其与自己讨厌的骑士连一条有向边，则本题就可以转化为求最大独立集。

由于该图有 $n$ 条边，因此图上可能会出现环。我们考虑断环，对于环上任意两个相邻的点 $u,v$，显然 $u,v$ 中要么两个都不选，要么只选一个。因此我们可以强制不选 $u$，$v$ 任意，或者强制不选 $v$，$u$ 任意。这样可以使原来的环变为树，用树形dp求最大独立集。

注意数据范围，记得开 $\text{long long}$

### Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 10;

int n, ans, cnt, root, a[N], b[N], head[N], f[N][2];
bool v[N];

struct xcj{
	int to, nxt;
} e[N];

inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	for (; ch < '0' || ch > '9'; w *= ch == '-' ? -1 : 1, ch = getchar());
	for (; ch >= '0' && ch <= '9'; s = s * 10 + ch - '0', ch = getchar());
	return s * w;
}

void add(int u, int v){e[++cnt] = {v, head[u]}, head[u] = cnt;}

void find_loop(int x){
	v[x] = 1;
	if (v[b[x]]) root = x;
	else find_loop(b[x]);
}

void dp(int x){
	f[x][1] = a[x], f[x][0] = 0;
	for (int i = head[x]; i; i = e[i].nxt){
		int y = e[i].to;
		if (y == root) f[y][1] = -2e9;
		else dp(y), f[x][1] += f[y][0], f[x][0] += max(f[y][0], f[y][1]);
	}
}

signed main(){
	n = read();
	for (int i = 1; i <= n; ++i) a[i] = read(), b[i] = read(), add(i, b[i]);
	for (int i = 1, val; i <= n; ++i)
		if (!v[i]) find_loop(i), dp(root), val = max(f[root][0], f[root][1]), root = b[root], dp(root), ans += max(val, max(f[root][0], f[root][1]));
	printf("%lld\n", ans);
	return 0;
}
```
